# coding: utf-8

"""
    ETSI ISG CIM / NGSI-LD API

    This OAS file describes the NGSI-LD API defined by the ETSI ISG CIM group. This Cross-domain Context Information Management API allows to provide, consume and subscribe to context information in multiple scenarios and involving multiple stakeholders  # noqa: E501

    The version of the OpenAPI document: latest
    Contact: NGSI-LD@etsi.org
    Generated by: https://openapi-generator.tech
"""

import decimal  # noqa: F401
import functools  # noqa: F401
import re  # noqa: F401
import sys  # noqa: F401
import typing  # noqa: F401
from datetime import date, datetime  # noqa: F401

from frozendict import frozendict  # noqa: F401
from ngsi_ld_client.schemas import (AnyTypeSchema, BinaryBase,  # noqa: F401
                                    BinarySchema, BoolBase, BoolSchema,
                                    ComposedBase, ComposedSchema,
                                    Configuration, DateBase, DateSchema,
                                    DateTimeBase, DateTimeSchema,
                                    DecimalSchema, DictBase, DictSchema,
                                    Float32Base, Float32Schema, Float64Base,
                                    Float64Schema, Int32Base, Int32Schema,
                                    Int64Base, Int64Schema, IntBase, IntSchema,
                                    ListBase, ListSchema, NoneBase, NoneSchema,
                                    NumberBase, NumberSchema, Schema, StrBase,
                                    StrSchema, Unset, UUIDBase, UUIDSchema,
                                    _SchemaEnumMaker, _SchemaTypeChecker,
                                    _SchemaValidator, none_type, unset)


class Subscription(
    ComposedSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    @classmethod
    @property
    @functools.cache
    def _composed_schemas(cls):
        # we need this here to make our import statements work
        # we must store _composed_schemas in here so the code is only run
        # when we invoke this method. If we kept this at the class
        # level we would get an error because the class level
        # code would be run when this module is imported, and these composed
        # classes don't exist yet because their module has not finished
        # loading


        class allOf_1(
            ComposedBase,
            DictSchema
        ):
            id = StrSchema


            class type(
                _SchemaEnumMaker(
                    enum_value_to_name={
                        "Subscription": "SUBSCRIPTION",
                    }
                ),
                StrSchema
            ):

                @classmethod
                @property
                def SUBSCRIPTION(cls):
                    return cls("Subscription")

            @classmethod
            @property
            def notification(cls) -> typing.Type['NotificationParams']:
                return NotificationParams


            class status(
                _SchemaEnumMaker(
                    enum_value_to_name={
                        "active": "ACTIVE",
                        "paused": "PAUSED",
                        "expired": "EXPIRED",
                    }
                ),
                StrSchema
            ):

                @classmethod
                @property
                def ACTIVE(cls):
                    return cls("active")

                @classmethod
                @property
                def PAUSED(cls):
                    return cls("paused")

                @classmethod
                @property
                def EXPIRED(cls):
                    return cls("expired")
            createdAt = DateTimeSchema
            modifiedAt = DateTimeSchema

            @classmethod
            @property
            @functools.cache
            def _composed_schemas(cls):
                # we need this here to make our import statements work
                # we must store _composed_schemas in here so the code is only run
                # when we invoke this method. If we kept this at the class
                # level we would get an error because the class level
                # code would be run when this module is imported, and these composed
                # classes don't exist yet because their module has not finished
                # loading
                allOf_0 = AnyTypeSchema
                allOf_1 = AnyTypeSchema
                return {
                    'allOf': [
                        allOf_0,
                        allOf_1,
                    ],
                    'oneOf': [
                    ],
                    'anyOf': [
                    ],
                    'not':
                        None
                }

            def __new__(
                cls,
                *args: typing.Union[dict, frozendict, ],
                id: typing.Union[id, Unset] = unset,
                type: typing.Union[type, Unset] = unset,
                notification: typing.Union['NotificationParams', Unset] = unset,
                status: typing.Union[status, Unset] = unset,
                createdAt: typing.Union[createdAt, Unset] = unset,
                modifiedAt: typing.Union[modifiedAt, Unset] = unset,
                _configuration: typing.Optional[Configuration] = None,
                **kwargs: typing.Type[Schema],
            ) -> 'allOf_1':
                return super().__new__(
                    cls,
                    *args,
                    id=id,
                    type=type,
                    notification=notification,
                    status=status,
                    createdAt=createdAt,
                    modifiedAt=modifiedAt,
                    _configuration=_configuration,
                    **kwargs,
                )
        return {
            'allOf': [
                SubscriptionFragment,
                allOf_1,
            ],
            'oneOf': [
            ],
            'anyOf': [
            ],
            'not':
                None
        }

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict, str, date, datetime, int, float, decimal.Decimal, None, list, tuple, bytes],
        _configuration: typing.Optional[Configuration] = None,
        **kwargs: typing.Type[Schema],
    ) -> 'Subscription':
        return super().__new__(
            cls,
            *args,
            _configuration=_configuration,
            **kwargs,
        )

from ngsi_ld_client.model.notification_params import NotificationParams
from ngsi_ld_client.model.subscription_fragment import SubscriptionFragment
